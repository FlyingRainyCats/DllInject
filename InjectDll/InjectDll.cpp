#include <Windows.h>
#include <tlhelp32.h>
#include <filesystem>
#include <iostream>
#include <string>
#include <vector>
#include "PEHelper.h"

namespace fs = std::filesystem;

unsigned char dllLoaderX86[] = {
    // setup frame
    0x59, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x08, 0x8B, 0x01, 0x89, 0x45, 0xF8,
    0x83, 0xC1, 0x04, 0x89, 0x4D, 0xFC, 0x8D, 0x4D, 0xF8, 0xE8, 0x04, 0x00,
    0x00, 0x00, 0xC9, 0xC2, 0x04, 0x00,

    // load dll
    0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x30, 0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,
    0x89, 0x4D, 0xF0, 0x53, 0x56, 0x8B, 0x40, 0x30, 0x57, 0xC7, 0x45, 0xD0,
    0x4E, 0x00, 0x54, 0x00, 0xC7, 0x45, 0xD4, 0x44, 0x00, 0x4C, 0x00, 0x8B,
    0x48, 0x0C, 0x8B, 0x41, 0x14, 0x83, 0xC1, 0x14, 0xC7, 0x45, 0xD8, 0x4C,
    0x00, 0x2E, 0x00, 0xC7, 0x45, 0xDC, 0x44, 0x00, 0x4C, 0x00, 0xC7, 0x45,
    0xE0, 0x4C, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xE4, 0x4C, 0x64, 0x72, 0x4C,
    0xC7, 0x45, 0xE8, 0x6F, 0x61, 0x64, 0x44, 0x66, 0xC7, 0x45, 0xEC, 0x6C,
    0x6C, 0xC6, 0x45, 0xEE, 0x00, 0x89, 0x4D, 0xF4, 0x89, 0x45, 0xFC, 0x3B,
    0xC1, 0x0F, 0x84, 0x8B, 0x00, 0x00, 0x00, 0x0F, 0xB7, 0x48, 0x1C, 0x8B,
    0x40, 0x20, 0xD1, 0xE9, 0x66, 0x83, 0x7C, 0x48, 0xFE, 0x5C, 0x8D, 0x04,
    0x48, 0x74, 0x0F, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x83, 0xE8, 0x02, 0x66,
    0x83, 0x78, 0xFE, 0x5C, 0x75, 0xF6, 0x8D, 0x4D, 0xD0, 0x89, 0x4D, 0xF8,
    0x3B, 0xC1, 0x74, 0x67, 0xBB, 0x4E, 0x00, 0x00, 0x00, 0x0F, 0xB7, 0x30,
    0x0F, 0xB7, 0xD6, 0x83, 0xC6, 0x9F, 0x66, 0x83, 0xFE, 0x19, 0x0F, 0xB7,
    0xF3, 0x8D, 0x4A, 0xE0, 0x0F, 0xB7, 0xF9, 0x8B, 0xCA, 0x0F, 0x47, 0xF9,
    0x8D, 0x4B, 0x9F, 0x0F, 0xB7, 0xD7, 0x66, 0x83, 0xF9, 0x19, 0x77, 0x06,
    0x8D, 0x4B, 0xE0, 0x0F, 0xB7, 0xF1, 0x66, 0x3B, 0xD6, 0x75, 0x16, 0x66,
    0x85, 0xD2, 0x74, 0x2B, 0x8B, 0x4D, 0xF8, 0x83, 0xC0, 0x02, 0x83, 0xC1,
    0x02, 0x89, 0x4D, 0xF8, 0x0F, 0xB7, 0x19, 0xEB, 0xB8, 0x8B, 0x45, 0xFC,
    0x8B, 0x00, 0x89, 0x45, 0xFC, 0x3B, 0x45, 0xF4, 0x0F, 0x85, 0x75, 0xFF,
    0xFF, 0xFF, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x8B,
    0x45, 0xFC, 0x8B, 0x78, 0x10, 0x85, 0xFF, 0x74, 0xED, 0x8B, 0x47, 0x3C,
    0x8B, 0x44, 0x38, 0x78, 0x03, 0xC7, 0x74, 0xE2, 0x8B, 0x48, 0x1C, 0x33,
    0xF6, 0x8B, 0x58, 0x18, 0x03, 0xCF, 0x89, 0x4D, 0xF8, 0x8B, 0x48, 0x24,
    0x03, 0xCF, 0x89, 0x4D, 0xF4, 0x8B, 0x48, 0x20, 0x03, 0xCF, 0x89, 0x4D,
    0xFC, 0x85, 0xDB, 0x74, 0xC1, 0x8B, 0x04, 0xB1, 0x8D, 0x55, 0xE4, 0x8B,
    0xCA, 0x03, 0xC7, 0x3B, 0xC8, 0x8B, 0x4D, 0xFC, 0x74, 0x2C, 0x85, 0xC0,
    0x74, 0x1A, 0xB1, 0x4C, 0x38, 0x08, 0x75, 0x11, 0x0F, 0x1F, 0x40, 0x00,
    0x84, 0xC9, 0x74, 0x1A, 0x8A, 0x4A, 0x01, 0x42, 0x40, 0x3A, 0x08, 0x74,
    0xF3, 0x8B, 0x4D, 0xFC, 0x46, 0x3B, 0xF3, 0x72, 0xCC, 0x5F, 0x5E, 0x33,
    0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x8B, 0x45, 0xF4, 0x8B, 0x4D, 0xF8,
    0x0F, 0xB7, 0x04, 0x70, 0x8B, 0x04, 0x81, 0x03, 0xC7, 0x0F, 0x84, 0x6F,
    0xFF, 0xFF, 0xFF, 0x8D, 0x4D, 0xF8, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x51, 0xFF, 0x75, 0xF0, 0x6A, 0x00, 0x6A, 0x00, 0xFF, 0xD0, 0x8B,
    0x45, 0xF8, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3};

int main_unicode(int argc, wchar_t** argv) {
  int target_pid{0};
  std::wstring target_process{};
  std::wstring target_dll{};
  bool create_thread{true};

  for (int i = 1; i < argc; i++) {
    const auto& arg = argv[i];
    if (_wcsicmp(arg, L"--pid") == 0) {
      target_pid = _wtoi(argv[++i]);
    } else if (_wcsicmp(arg, L"--name") == 0) {
      target_process = argv[++i];
    } else if (_wcsicmp(arg, L"--dll") == 0) {
      target_dll = argv[++i];
    } else if (_wcsicmp(arg, L"--create-thread") == 0) {
      create_thread = true;
    } else if (_wcsicmp(arg, L"--no-create-thread") == 0) {
      create_thread = false;
    }
  }

  if (target_pid == 0) {
    if (target_process.empty()) {
      std::cerr << "ERR: `--pid` and `--name` missing.\n";
      return 1;
    }

    auto pids =
        PEHelper::Win32Process::FindProcessIdByName(target_process.c_str());
    if (pids.empty()) {
      std::cerr << "ERR: no process found by name.\n";
      return 2;
    } else if (pids.size() > 1) {
      std::cerr << "ERR: multiple process found, pid:\n";
      for (auto& pid : pids) {
        std::cerr << "  - " << pid << "\n";
      }
      std::cerr << "\n";
      return 3;
    }
    target_pid = pids[0];
  }
  if (target_dll.empty()) {
    std::cerr << "ERR: dll not specified.\n";
    return 4;
  }
  fs::path path_dll = fs::absolute(target_dll);
  if (!fs::exists(path_dll)) {
    std::cerr << "ERR: dll does not exist.\n";
    return 5;
  }
  target_dll = path_dll.wstring();

  std::vector<uint8_t> payload{0xE8, 0, 0, 0, 0};
  uint16_t strLen = static_cast<uint16_t>(target_dll.size() * 2);
  payload.push_back(static_cast<uint8_t>(strLen));
  payload.push_back(static_cast<uint8_t>(strLen >> 8));
  strLen += 2;
  payload.push_back(static_cast<uint8_t>(strLen));
  payload.push_back(static_cast<uint8_t>(strLen >> 8));
  for (auto& chr : target_dll) {
    payload.push_back(static_cast<uint8_t>(chr));
    payload.push_back(static_cast<uint8_t>(chr >> 8));
  }
  payload.push_back(0);
  payload.push_back(0);
  *(uint32_t*)&payload.at(1) = static_cast<uint32_t>(payload.size() - 5);

  PEHelper::Win32Process proc(target_pid);

  if (proc.IsProcessX86()) {
    payload.insert(payload.end(), &dllLoaderX86[0],
                   &dllLoaderX86[sizeof(dllLoaderX86)]);
  } else {
    fprintf_s(stderr, "ERR: payload does not support this arch: 0x%04x.\n",
              proc.GetProcessType());
    return 6;
  }

  void* ptrAddress = proc.SetupShellCode(payload.data(), payload.size());

  if (!create_thread) {
    fprintf_s(stderr, "Ready: %p\n", ptrAddress);
  } else {
    fprintf_s(stderr, "Running: %p\n", ptrAddress);
    HANDLE hThread = proc.CreateThread(ptrAddress, nullptr);
    WaitForSingleObject(hThread, INFINITE);
    DWORD exitCode{0};
    if (GetExitCodeThread(hThread, &exitCode)) {
      fprintf_s(stderr, "module available at: 0x%08x\n", (exitCode));
    } else {
      fprintf_s(stderr, "get exit code for thread failed\n");
    }
  }

  return 0;
}

int main() {
  int argc{0};
  auto** argv = CommandLineToArgvW(GetCommandLineW(), &argc);

  return main_unicode(argc, argv);
}
